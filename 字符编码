	1. ASCII编码
	2. 中文编码
	字符集和编码名称基本相同
	• 字符集 GB2412
	https://www.bilibili.com/video/BV1gZ4y1x7p7/?spm_id_from=333.337.top_right_bar_window_custom_collection.content.click
		1) 94个分区，8836个码位，最大2个字节
		2) 01-09区收录除汉字外的682个字符		
		3) 10-15区空白区
		4) 16-55区收录3755个一级汉字，按照拼音排序		
		5) 56-87区收录3088个二级汉字，按照部首/笔画排序
		6) 88-94区空白区
		7) GB2312字符集编码
		饼，区号17=0x11，区内码93=0x5D，分别加上0xA0再拼接起来，0x11+0xA0=0xB1，0x5D+0xA0=0xFD，饼的编码喂0xB1FD，加上0xA0可以有效于其他编码区分，并且因为分区的数量和分区内的码位不会超过0xA0，不会导致重码
		8) 解码过程，首位为0，按照ASCII解码，首位为1，按照中文解码
		9) 缺点，4字节空间浪费，2^15 = 32768 > 8836 > 6763
	• GBK字符集
	【编码】中文编码介绍_哔哩哔哩_bilibili
		1) GBK兼容GB2312，最大两个字节，与GB2312比较，新增20000个汉字和符号（两万），几千个少数民族字符
		2) 将GB2312的区号+0xA0当成真正的区号，区内号+0xA0当成真区内号，各自都扩展
		3) 原来的GB2312其中中文的范围16区到87区的汉字的编码范围为 0xB0A1 - 0xF7FE 照搬
		4) 前面扩展 0x8140 - 0xA0FE，包含CJK的6080个汉字
		5) 穿插扩展 0xAA40 - 0xFEA0，（GB2312中分区内还有空位可以填），包含CJK汉字和增补汉字8160个 
		6) 0xAAA1 - 0xAFFE，0xF8A1 - 0xFEFE，0xA140 - 0xA7A0，三个为符号区，包含1000多个符号
		7) 瞭望的“瞭”，GB2312中不包含，但是再GBK中就有，编码为 0xB274
		8) 从GBK编码的值可以发现，汉字二进制形状为 1xxxxxxx xxxxxxxx
	• GB18030字符集
		1) 最大4字节，完全兼容GB2312，大部分兼容GBK（完全兼容其中的汉字部分）		
		2) “㞎”在GBK中没有，在GB18030中有，编码为0x8230CB34
		3) CJK = 中日韩，这个主要是指的东亚地区使用汉字及部分衍生偏僻字的字符集
	3. Unicode
	https://unicode-table.com/
	Unicode是一套标准规则，包括字符集和编码规则，名称不一样
	• 字符集
		○ ucs-2
		○ ucs-4
	• 编码规则
	一听就能懂字符集、ASCII、GBK、Unicode、UTF-8、字符编码、解码、乱码问题的讲解_哔哩哔哩_bilibili
		○ Utf-16
		只覆盖部分字符集
		○ utf-32
		所有字符用4字节表示，浪费大量存储空间
		○ utf-8
		1) 空间友好，变长编码，理论6字节，常用2-4字节。二进制中每个字节都有前缀，2-4字节的第一个字节前缀对应字节数的1再+0，后面的字节前缀都是10，字节前缀可以很方便的帮助解码器变长解码
		2) 1字节（ASCII）
		二进制形状： 0xxxxxxx
		3) 2字节（希腊，拉丁）
		二进制形状： 110xxxxx 10xxxxxx
		4) 3字节（中日韩）
		二进制形状： 1110xxxx 10xxxxxx 10xxxxxx
		5) 4字节（不常用字符）
		二进制形状： 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
		6) 编码方法
		我 - Ideograph our, us, i, me, my, we CJK: U+6211 - Unicode Character Table (unicode-table.com)
		举例：“我”在Unicode表中为\u6211（注意是2字节），二进制 01100010 00010001，utf-8编码为3字节，所以需要切分为3块，对应utf-8的规则中3字节编码的空位1110xxxx 10xxxxxx 10xxxxxx，将01100010 00010001从右往左切成对应数量的3块，结果 0110/0010 00/010001，分别填充，得到utf-8的编码结果 1110/0110 10/001000 10/010001 = 0xE68891
		○ 
	4. 其他编码
总结
	• 设定字符集，制作码表，设置规则，使用规则编码得到二进制数据，二进制数据使用正确规则查表解码，规则错误查错表导致乱码
	• 码表本质是区分不同字符的位置的信息
	• 编码如果直接复制码表，导致空间时间损耗，所以添加编码解码规则，降低空间和时间损耗
	• 乱码只是影响人类阅读，关我数据什么事，乱码不用慌，问作者用的是什么编码，再对应解码，问不出来，就拿一些常用的解码都试一试
	• 编码转换的问题，因为字符集的兼容性的原因，一些字符集可以无损转换为其他字符集，比如GB2312转为GBK，但是反向GBK转到GB2312就会出现有些字符无法正确转换，比如“瞭”字。
